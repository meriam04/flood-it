void set_A9_IRQ_stack(void);
void config_GIC(void);

void config_KEYs(void);
void enable_A9_interrupts(void);

//put our own ISR variables here
/* key_dir and pattern are written by interrupt service routines; we have to
* declare these as volatile to avoid the compiler caching their values in
* registers */
volatile int tick = 0; // set to 1 every time the HPS timer expires
volatile int key_dir = 0;
volatile int pattern = 0x0F0F0F0F; // pattern for LED lights
/* ********************************************************************************
* This program demonstrates use of interrupts with C code. It first starts
* two timers: an HPS timer, and the FPGA interval timer. The program responds
* to interrupts from these timers in addition to the pushbutton KEYs in the
* FPGA.
*
* The interrupt service routine for the HPS timer causes the main program to
* flash the green light connected to the HPS GPIO1 port.
*
* The interrupt service routine for the interval timer displays a pattern on
* the LED lights, and shifts this pattern either left or right. The shifting
* direction is reversed when KEY[1] is pressed I'VE EXCLUDED THE TIMER INTERRUPTS
********************************************************************************/
int main(void)
{
    //volatile int * HPS_GPIO1_ptr = (int *)HPS_GPIO1_BASE; // GPIO1 base address
    //volatile int HPS_timer_LEDG = 0x01000000; // value to turn on the HPS green light LEDG
    
    set_A9_IRQ_stack(); // initialize the stack pointer for IRQ mode
    config_GIC(); // configure the general interrupt controller

    // enable interrupts on external devices
    config_KEYs(); // configure pushbutton KEYs to generate interrupts
    
    enable_A9_interrupts(); // enable interrupts on proc
    
    while (1) {   //program to loop while waiting for interrupts
        if (tick) {
            tick = 0;
            *HPS_GPIO1_ptr = HPS_timer_LEDG; // turn on/off the green light LEDG
            HPS_timer_LEDG ^= 0x01000000; // toggle the bit that controls LEDG
        }
    }
}

/* setup the KEY interrupts in the FPGA */
void config_KEYs()
{
    volatile int * KEY_ptr = (int *)KEY_BASE; // pushbutton KEY address
    *(KEY_ptr + 2) = 0x3; // enable interrupts for KEY[1]
}

/*Initialize the banked stack pointer register for IRQ mode*/
void set_A9_IRQ_stack(void)
{
    int stack, mode;
    stack = A9_ONCHIP_END - 7; // top of A9 onchip memory, aligned to 8 bytes
    /* change processor to IRQ mode with interrupts disabled */
    mode = INT_DISABLE | IRQ_MODE;
    asm("msr cpsr, %[ps]" : : [ps] "r"(mode));
    /* set banked stack pointer */
    asm("mov sp, %[ps]" : : [ps] "r"(stack));
    /* go back to SVC mode before executing subroutine return! */
    mode = INT_DISABLE | SVC_MODE;
    asm("msr cpsr, %[ps]" : : [ps] "r"(mode));
}

/*
* Turn on interrupts in the ARM processor
*/
void enable_A9_interrupts(void)
{
    int status = SVC_MODE | INT_ENABLE;
    asm("msr cpsr, %[ps]" : : [ps] "r"(status));
}

/* Configure the Generic Interrupt Controller (GIC)
*/
void config_GIC(void)
{
    int address; // used to calculate register addresses
    /* configure the HPS timer interrupt */
    *((int *)0xFFFED8C4) = 0x01000000;
    *((int *)0xFFFED118) = 0x00000080;
    
    /* configure the FPGA interval timer and KEYs interrupts */
    *((int *)0xFFFED848) = 0x00000101;
    *((int *)0xFFFED108) = 0x00000300;
    
    // Set Interrupt Priority Mask Register (ICCPMR). Enable interrupts of all
    //priorities
    address = MPCORE_GIC_CPUIF + ICCPMR;
    *((int *)address) = 0xFFFF;
    
    // Set CPU Interface Control Register (ICCICR). Enable signaling of
    // interrupts
    address = MPCORE_GIC_CPUIF + ICCICR;
    *((int *)address) = ENABLE;
    
    // Configure the Distributor Control Register (ICDDCR) to send pending
    // interrupts to CPUs
    address = MPCORE_GIC_DIST + ICDDCR;
    *((int *)address) = ENABLE;
}
            
            
            
            
            
